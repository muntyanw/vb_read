[
    {
        "label": "argparse",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "argparse",
        "description": "argparse",
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "glob",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "glob",
        "description": "glob",
        "detail": "glob",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "shutil",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "shutil",
        "description": "shutil",
        "detail": "shutil",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "sysconfig",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sysconfig",
        "description": "sysconfig",
        "detail": "sysconfig",
        "documentation": {}
    },
    {
        "label": "tempfile",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tempfile",
        "description": "tempfile",
        "detail": "tempfile",
        "documentation": {}
    },
    {
        "label": "winreg",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "winreg",
        "description": "winreg",
        "detail": "winreg",
        "documentation": {}
    },
    {
        "label": "site",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "site",
        "description": "site",
        "detail": "site",
        "documentation": {}
    },
    {
        "label": "subprocess",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "subprocess",
        "description": "subprocess",
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "asyncio",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "asyncio",
        "description": "asyncio",
        "detail": "asyncio",
        "documentation": {}
    },
    {
        "label": "httpx",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "httpx",
        "description": "httpx",
        "detail": "httpx",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timezone",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "send_for_analysis",
        "importPath": "dispatcher.dispatch_client",
        "description": "dispatcher.dispatch_client",
        "isExtraImport": true,
        "detail": "dispatcher.dispatch_client",
        "documentation": {}
    },
    {
        "label": "DispatchResult",
        "importPath": "dispatcher.dispatch_client",
        "description": "dispatcher.dispatch_client",
        "isExtraImport": true,
        "detail": "dispatcher.dispatch_client",
        "documentation": {}
    },
    {
        "label": "send_for_analysis",
        "importPath": "dispatcher.dispatch_client",
        "description": "dispatcher.dispatch_client",
        "isExtraImport": true,
        "detail": "dispatcher.dispatch_client",
        "documentation": {}
    },
    {
        "label": "log_and_print",
        "importPath": "log",
        "description": "log",
        "isExtraImport": true,
        "detail": "log",
        "documentation": {}
    },
    {
        "label": "log_and_print",
        "importPath": "log",
        "description": "log",
        "isExtraImport": true,
        "detail": "log",
        "documentation": {}
    },
    {
        "label": "log_and_print",
        "importPath": "log",
        "description": "log",
        "isExtraImport": true,
        "detail": "log",
        "documentation": {}
    },
    {
        "label": "log_and_print",
        "importPath": "log",
        "description": "log",
        "isExtraImport": true,
        "detail": "log",
        "documentation": {}
    },
    {
        "label": "log_and_print",
        "importPath": "log",
        "description": "log",
        "isExtraImport": true,
        "detail": "log",
        "documentation": {}
    },
    {
        "label": "log_and_print",
        "importPath": "log",
        "description": "log",
        "isExtraImport": true,
        "detail": "log",
        "documentation": {}
    },
    {
        "label": "log_and_print",
        "importPath": "log",
        "description": "log",
        "isExtraImport": true,
        "detail": "log",
        "documentation": {}
    },
    {
        "label": "log_and_print",
        "importPath": "log",
        "description": "log",
        "isExtraImport": true,
        "detail": "log",
        "documentation": {}
    },
    {
        "label": "log_and_print",
        "importPath": "log",
        "description": "log",
        "isExtraImport": true,
        "detail": "log",
        "documentation": {}
    },
    {
        "label": "log_and_print",
        "importPath": "log",
        "description": "log",
        "isExtraImport": true,
        "detail": "log",
        "documentation": {}
    },
    {
        "label": "log_and_print",
        "importPath": "log",
        "description": "log",
        "isExtraImport": true,
        "detail": "log",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "read_setting",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "read_setting",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "write_setting",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "read_setting",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "showImage",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "take_screenshot",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "is_video_file",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "get_video_dimensions_cv2",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "take_screenshot",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "preprocess_image",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "show_screen_with_region",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "logging",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "logging",
        "description": "logging",
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "ctypes",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ctypes",
        "description": "ctypes",
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "cv2",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "cv2",
        "description": "cv2",
        "detail": "cv2",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "ImageGrab",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "Image",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "ImageGrab",
        "importPath": "PIL",
        "description": "PIL",
        "isExtraImport": true,
        "detail": "PIL",
        "documentation": {}
    },
    {
        "label": "capture_and_recognize",
        "importPath": "recognize_text",
        "description": "recognize_text",
        "isExtraImport": true,
        "detail": "recognize_text",
        "documentation": {}
    },
    {
        "label": "capture_and_find_multiple_text_coordinates",
        "importPath": "recognize_text",
        "description": "recognize_text",
        "isExtraImport": true,
        "detail": "recognize_text",
        "documentation": {}
    },
    {
        "label": "find_text_upward_with_highlight",
        "importPath": "recognize_text",
        "description": "recognize_text",
        "isExtraImport": true,
        "detail": "recognize_text",
        "documentation": {}
    },
    {
        "label": "capture_and_recognize",
        "importPath": "recognize_text",
        "description": "recognize_text",
        "isExtraImport": true,
        "detail": "recognize_text",
        "documentation": {}
    },
    {
        "label": "tkinter",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tkinter",
        "description": "tkinter",
        "detail": "tkinter",
        "documentation": {}
    },
    {
        "label": "startTgClient",
        "importPath": "tg",
        "description": "tg",
        "isExtraImport": true,
        "detail": "tg",
        "documentation": {}
    },
    {
        "label": "send_message_to_tg_channel",
        "importPath": "tg",
        "description": "tg",
        "isExtraImport": true,
        "detail": "tg",
        "documentation": {}
    },
    {
        "label": "startTgClient",
        "importPath": "tg",
        "description": "tg",
        "isExtraImport": true,
        "detail": "tg",
        "documentation": {}
    },
    {
        "label": "send_message_to_tg_channel",
        "importPath": "tg",
        "description": "tg",
        "isExtraImport": true,
        "detail": "tg",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "vb_utils",
        "description": "vb_utils",
        "isExtraImport": true,
        "detail": "vb_utils",
        "documentation": {}
    },
    {
        "label": "pyperclip",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pyperclip",
        "description": "pyperclip",
        "detail": "pyperclip",
        "documentation": {}
    },
    {
        "label": "load_previous_text",
        "importPath": "find_message",
        "description": "find_message",
        "isExtraImport": true,
        "detail": "find_message",
        "documentation": {}
    },
    {
        "label": "save_current_text",
        "importPath": "find_message",
        "description": "find_message",
        "isExtraImport": true,
        "detail": "find_message",
        "documentation": {}
    },
    {
        "label": "remove_service_symbols_and_spaces",
        "importPath": "find_message",
        "description": "find_message",
        "isExtraImport": true,
        "detail": "find_message",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "find_message",
        "description": "find_message",
        "isExtraImport": true,
        "detail": "find_message",
        "documentation": {}
    },
    {
        "label": "Application",
        "importPath": "pywinauto",
        "description": "pywinauto",
        "isExtraImport": true,
        "detail": "pywinauto",
        "documentation": {}
    },
    {
        "label": "Application",
        "importPath": "pywinauto",
        "description": "pywinauto",
        "isExtraImport": true,
        "detail": "pywinauto",
        "documentation": {}
    },
    {
        "label": "mouse",
        "importPath": "pywinauto",
        "description": "pywinauto",
        "isExtraImport": true,
        "detail": "pywinauto",
        "documentation": {}
    },
    {
        "label": "BytesIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "hashlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "hashlib",
        "description": "hashlib",
        "detail": "hashlib",
        "documentation": {}
    },
    {
        "label": "ScreenRegionSelector",
        "importPath": "ScreenRegionSelector",
        "description": "ScreenRegionSelector",
        "isExtraImport": true,
        "detail": "ScreenRegionSelector",
        "documentation": {}
    },
    {
        "label": "keyboard",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "keyboard",
        "description": "keyboard",
        "detail": "keyboard",
        "documentation": {}
    },
    {
        "label": "pyautogui",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pyautogui",
        "description": "pyautogui",
        "detail": "pyautogui",
        "documentation": {}
    },
    {
        "label": "show_position",
        "importPath": "paint",
        "description": "paint",
        "isExtraImport": true,
        "detail": "paint",
        "documentation": {}
    },
    {
        "label": "pytesseract",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pytesseract",
        "description": "pytesseract",
        "detail": "pytesseract",
        "documentation": {}
    },
    {
        "label": "Output",
        "importPath": "pytesseract",
        "description": "pytesseract",
        "isExtraImport": true,
        "detail": "pytesseract",
        "documentation": {}
    },
    {
        "label": "RPCError",
        "importPath": "telethon.errors",
        "description": "telethon.errors",
        "isExtraImport": true,
        "detail": "telethon.errors",
        "documentation": {}
    },
    {
        "label": "TelegramClient",
        "importPath": "telethon",
        "description": "telethon",
        "isExtraImport": true,
        "detail": "telethon",
        "documentation": {}
    },
    {
        "label": "init",
        "importPath": "init",
        "description": "init",
        "isExtraImport": true,
        "detail": "init",
        "documentation": {}
    },
    {
        "label": "DocumentAttributeVideo",
        "importPath": "telethon.tl.types",
        "description": "telethon.tl.types",
        "isExtraImport": true,
        "detail": "telethon.tl.types",
        "documentation": {}
    },
    {
        "label": "DocumentAttributeFilename",
        "importPath": "telethon.tl.types",
        "description": "telethon.tl.types",
        "isExtraImport": true,
        "detail": "telethon.tl.types",
        "documentation": {}
    },
    {
        "label": "signal",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "signal",
        "description": "signal",
        "detail": "signal",
        "documentation": {}
    },
    {
        "label": "keyboard",
        "importPath": "pynput",
        "description": "pynput",
        "isExtraImport": true,
        "detail": "pynput",
        "documentation": {}
    },
    {
        "label": "threading",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "threading",
        "description": "threading",
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "screen_region",
        "description": "screen_region",
        "isExtraImport": true,
        "detail": "screen_region",
        "documentation": {}
    },
    {
        "label": "main",
        "importPath": "vb",
        "description": "vb",
        "isExtraImport": true,
        "detail": "vb",
        "documentation": {}
    },
    {
        "label": "Tee",
        "kind": 6,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "class Tee:\n    def __init__(self, file):\n        self.f = file\n    def write(self, what):\n        if self.f is not None:\n            try:\n                self.f.write(what.replace(\"\\n\", \"\\r\\n\"))\n            except OSError:\n                pass\n        tee_f.write(what)",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "get_root_hkey",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def get_root_hkey():\n    try:\n        winreg.OpenKey(\n            winreg.HKEY_LOCAL_MACHINE, root_key_name, 0, winreg.KEY_CREATE_SUB_KEY\n        )\n        return winreg.HKEY_LOCAL_MACHINE\n    except OSError:\n        # Either not exist, or no permissions to create subkey means\n        # must be HKCU\n        return winreg.HKEY_CURRENT_USER",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "create_shortcut",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def create_shortcut(\n    path, description, filename, arguments=\"\", workdir=\"\", iconpath=\"\", iconindex=0\n):\n    import pythoncom\n    from win32com.shell import shell\n    ilink = pythoncom.CoCreateInstance(\n        shell.CLSID_ShellLink,\n        None,\n        pythoncom.CLSCTX_INPROC_SERVER,\n        shell.IID_IShellLink,",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "get_special_folder_path",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def get_special_folder_path(path_name):\n    from win32com.shell import shell, shellcon\n    for maybe in \"\"\"\n        CSIDL_COMMON_STARTMENU CSIDL_STARTMENU CSIDL_COMMON_APPDATA\n        CSIDL_LOCAL_APPDATA CSIDL_APPDATA CSIDL_COMMON_DESKTOPDIRECTORY\n        CSIDL_DESKTOPDIRECTORY CSIDL_COMMON_STARTUP CSIDL_STARTUP\n        CSIDL_COMMON_PROGRAMS CSIDL_PROGRAMS CSIDL_PROGRAM_FILES_COMMON\n        CSIDL_PROGRAM_FILES CSIDL_FONTS\"\"\".split():\n        if maybe == path_name:\n            csidl = getattr(shellcon, maybe)",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "CopyTo",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def CopyTo(desc, src, dest):\n    import win32api\n    import win32con\n    while 1:\n        try:\n            win32api.CopyFile(src, dest, 0)\n            return\n        except win32api.error as details:\n            if details.winerror == 5:  # access denied - user not admin.\n                raise",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "LoadSystemModule",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def LoadSystemModule(lib_dir, modname):\n    # See if this is a debug build.\n    import importlib.machinery\n    import importlib.util\n    suffix = \"_d\" if \"_d.pyd\" in importlib.machinery.EXTENSION_SUFFIXES else \"\"\n    filename = \"%s%d%d%s.dll\" % (\n        modname,\n        sys.version_info.major,\n        sys.version_info.minor,\n        suffix,",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "SetPyKeyVal",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def SetPyKeyVal(key_name, value_name, value):\n    root_hkey = get_root_hkey()\n    root_key = winreg.OpenKey(root_hkey, root_key_name)\n    try:\n        my_key = winreg.CreateKey(root_key, key_name)\n        try:\n            winreg.SetValueEx(my_key, value_name, 0, winreg.REG_SZ, value)\n            if verbose:\n                print(f\"-> {root_key_name}\\\\{key_name}[{value_name}]={value!r}\")\n        finally:",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "UnsetPyKeyVal",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def UnsetPyKeyVal(key_name, value_name, delete_key=False):\n    root_hkey = get_root_hkey()\n    root_key = winreg.OpenKey(root_hkey, root_key_name)\n    try:\n        my_key = winreg.OpenKey(root_key, key_name, 0, winreg.KEY_SET_VALUE)\n        try:\n            winreg.DeleteValue(my_key, value_name)\n            if verbose:\n                print(f\"-> DELETE {root_key_name}\\\\{key_name}[{value_name}]\")\n        finally:",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "RegisterCOMObjects",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def RegisterCOMObjects(register=True):\n    import win32com.server.register\n    if register:\n        func = win32com.server.register.RegisterClasses\n    else:\n        func = win32com.server.register.UnregisterClasses\n    flags = {}\n    if not verbose:\n        flags[\"quiet\"] = 1\n    for module, klass_name in com_modules:",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "RegisterHelpFile",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def RegisterHelpFile(register=True, lib_dir=None):\n    if lib_dir is None:\n        lib_dir = sysconfig.get_paths()[\"platlib\"]\n    if register:\n        # Register the .chm help file.\n        chm_file = os.path.join(lib_dir, \"PyWin32.chm\")\n        if os.path.isfile(chm_file):\n            # This isn't recursive, so if 'Help' doesn't exist, we croak\n            SetPyKeyVal(\"Help\", None, None)\n            SetPyKeyVal(\"Help\\\\Pythonwin Reference\", None, chm_file)",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "RegisterPythonwin",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def RegisterPythonwin(register=True, lib_dir=None):\n    \"\"\"Add (or remove) Pythonwin to context menu for python scripts.\n    ??? Should probably also add Edit command for pys files also.\n    Also need to remove these keys on uninstall, but there's no function\n    to add registry entries to uninstall log ???\n    \"\"\"\n    import os\n    if lib_dir is None:\n        lib_dir = sysconfig.get_paths()[\"platlib\"]\n    classes_root = get_root_hkey()",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "get_shortcuts_folder",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def get_shortcuts_folder():\n    if get_root_hkey() == winreg.HKEY_LOCAL_MACHINE:\n        try:\n            fldr = get_special_folder_path(\"CSIDL_COMMON_PROGRAMS\")\n        except OSError:\n            # No CSIDL_COMMON_PROGRAMS on this platform\n            fldr = get_special_folder_path(\"CSIDL_PROGRAMS\")\n    else:\n        # non-admin install - always goes in this user's start menu.\n        fldr = get_special_folder_path(\"CSIDL_PROGRAMS\")",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "get_system_dir",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def get_system_dir():\n    import win32api  # we assume this exists.\n    try:\n        import pythoncom\n        import win32process\n        from win32com.shell import shell, shellcon\n        try:\n            if win32process.IsWow64Process():\n                return shell.SHGetSpecialFolderPath(0, shellcon.CSIDL_SYSTEMX86)\n            return shell.SHGetSpecialFolderPath(0, shellcon.CSIDL_SYSTEM)",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "fixup_dbi",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def fixup_dbi():\n    # We used to have a dbi.pyd with our .pyd files, but now have a .py file.\n    # If the user didn't uninstall, they will find the .pyd which will cause\n    # problems - so handle that.\n    import win32api\n    import win32con\n    pyd_name = os.path.join(os.path.dirname(win32api.__file__), \"dbi.pyd\")\n    pyd_d_name = os.path.join(os.path.dirname(win32api.__file__), \"dbi_d.pyd\")\n    py_name = os.path.join(os.path.dirname(win32con.__file__), \"dbi.py\")\n    for this_pyd in (pyd_name, pyd_d_name):",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "install",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def install(lib_dir):\n    import traceback\n    # The .pth file is now installed as a regular file.\n    # Create the .pth file in the site-packages dir, and use only relative paths\n    # We used to write a .pth directly to sys.prefix - clobber it.\n    if os.path.isfile(os.path.join(sys.prefix, \"pywin32.pth\")):\n        os.unlink(os.path.join(sys.prefix, \"pywin32.pth\"))\n    # The .pth may be new and therefore not loaded in this session.\n    # Setup the paths just in case.\n    for name in \"win32 win32\\\\lib Pythonwin\".split():",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "uninstall",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def uninstall(lib_dir):\n    # First ensure our system modules are loaded from pywin32_system, so\n    # we can remove the ones we copied...\n    LoadSystemModule(lib_dir, \"pywintypes\")\n    LoadSystemModule(lib_dir, \"pythoncom\")\n    try:\n        RegisterCOMObjects(False)\n    except Exception as why:\n        print(f\"Failed to unregister COM objects: {why}\")\n    try:",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "verify_destination",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def verify_destination(location: str) -> str:\n    location = os.path.abspath(location)\n    if not os.path.isdir(location):\n        raise argparse.ArgumentTypeError(\n            f'Path \"{location}\" is not an existing directory!'\n        )\n    return location\ndef main():\n    parser = argparse.ArgumentParser(\n        formatter_class=argparse.RawDescriptionHelpFormatter,",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "def main():\n    parser = argparse.ArgumentParser(\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n        description=\"\"\"A post-install script for the pywin32 extensions.\n    * Typical usage:\n    > python -m pywin32_postinstall -install\n    * or (shorter but you don't have control over which python environment is used)\n    > pywin32_postinstall -install\n    You need to execute this script, with a '-install' parameter,\n    to ensure the environment is setup correctly to install COM objects, services, etc.",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "tee_f",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "tee_f = open(\n    os.path.join(\n        tempfile.gettempdir(),  # Send output somewhere so it can be found if necessary...\n        \"pywin32_postinstall.log\",\n    ),\n    \"w\",\n)\nclass Tee:\n    def __init__(self, file):\n        self.f = file",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "sys.stderr",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "sys.stderr = Tee(sys.stderr)\nsys.stdout = Tee(sys.stdout)\ncom_modules = [\n    # module_name,                      class_names\n    (\"win32com.servers.interp\", \"Interpreter\"),\n    (\"win32com.servers.dictionary\", \"DictionaryPolicy\"),\n    (\"win32com.axscript.client.pyscript\", \"PyScript\"),\n]\n# Is this a 'silent' install - ie, avoid all dialogs.\n# Different than 'verbose'",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "sys.stdout",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "sys.stdout = Tee(sys.stdout)\ncom_modules = [\n    # module_name,                      class_names\n    (\"win32com.servers.interp\", \"Interpreter\"),\n    (\"win32com.servers.dictionary\", \"DictionaryPolicy\"),\n    (\"win32com.axscript.client.pyscript\", \"PyScript\"),\n]\n# Is this a 'silent' install - ie, avoid all dialogs.\n# Different than 'verbose'\nsilent = 0",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "com_modules",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "com_modules = [\n    # module_name,                      class_names\n    (\"win32com.servers.interp\", \"Interpreter\"),\n    (\"win32com.servers.dictionary\", \"DictionaryPolicy\"),\n    (\"win32com.axscript.client.pyscript\", \"PyScript\"),\n]\n# Is this a 'silent' install - ie, avoid all dialogs.\n# Different than 'verbose'\nsilent = 0\n# Verbosity of output messages.",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "silent",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "silent = 0\n# Verbosity of output messages.\nverbose = 1\nroot_key_name = \"Software\\\\Python\\\\PythonCore\\\\\" + sys.winver\ndef get_root_hkey():\n    try:\n        winreg.OpenKey(\n            winreg.HKEY_LOCAL_MACHINE, root_key_name, 0, winreg.KEY_CREATE_SUB_KEY\n        )\n        return winreg.HKEY_LOCAL_MACHINE",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "verbose",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "verbose = 1\nroot_key_name = \"Software\\\\Python\\\\PythonCore\\\\\" + sys.winver\ndef get_root_hkey():\n    try:\n        winreg.OpenKey(\n            winreg.HKEY_LOCAL_MACHINE, root_key_name, 0, winreg.KEY_CREATE_SUB_KEY\n        )\n        return winreg.HKEY_LOCAL_MACHINE\n    except OSError:\n        # Either not exist, or no permissions to create subkey means",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "root_key_name",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_postinstall",
        "description": ".venv.Scripts.pywin32_postinstall",
        "peekOfCode": "root_key_name = \"Software\\\\Python\\\\PythonCore\\\\\" + sys.winver\ndef get_root_hkey():\n    try:\n        winreg.OpenKey(\n            winreg.HKEY_LOCAL_MACHINE, root_key_name, 0, winreg.KEY_CREATE_SUB_KEY\n        )\n        return winreg.HKEY_LOCAL_MACHINE\n    except OSError:\n        # Either not exist, or no permissions to create subkey means\n        # must be HKCU",
        "detail": ".venv.Scripts.pywin32_postinstall",
        "documentation": {}
    },
    {
        "label": "run_test",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_testall",
        "description": ".venv.Scripts.pywin32_testall",
        "peekOfCode": "def run_test(script, cmdline_extras):\n    dirname, scriptname = os.path.split(script)\n    # some tests prefer to be run from their directory.\n    cmd = [sys.executable, \"-u\", scriptname] + cmdline_extras\n    print(\"--- Running '%s' ---\" % script)\n    sys.stdout.flush()\n    result = subprocess.run(cmd, check=False, cwd=dirname)\n    print(f\"*** Test script '{script}' exited with {result.returncode}\")\n    sys.stdout.flush()\n    if result.returncode:",
        "detail": ".venv.Scripts.pywin32_testall",
        "documentation": {}
    },
    {
        "label": "find_and_run",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_testall",
        "description": ".venv.Scripts.pywin32_testall",
        "peekOfCode": "def find_and_run(possible_locations, extras):\n    for maybe in possible_locations:\n        if os.path.isfile(maybe):\n            run_test(maybe, extras)\n            break\n    else:\n        raise RuntimeError(\n            \"Failed to locate a test script in one of %s\" % possible_locations\n        )\ndef main():",
        "detail": ".venv.Scripts.pywin32_testall",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": ".venv.Scripts.pywin32_testall",
        "description": ".venv.Scripts.pywin32_testall",
        "peekOfCode": "def main():\n    import argparse\n    code_directories = [project_root] + site_packages\n    parser = argparse.ArgumentParser(\n        description=\"A script to trigger tests in all subprojects of PyWin32.\"\n    )\n    parser.add_argument(\n        \"-no-user-interaction\",\n        default=False,\n        action=\"store_true\",",
        "detail": ".venv.Scripts.pywin32_testall",
        "documentation": {}
    },
    {
        "label": "project_root",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_testall",
        "description": ".venv.Scripts.pywin32_testall",
        "peekOfCode": "project_root = os.path.dirname(os.path.dirname(os.path.dirname(__file__)))\nsite_packages = [site.getusersitepackages()] + site.getsitepackages()\nfailures = []\n# Run a test using subprocess and wait for the result.\n# If we get an returncode != 0, we know that there was an error, but we don't\n# abort immediately - we run as many tests as we can.\ndef run_test(script, cmdline_extras):\n    dirname, scriptname = os.path.split(script)\n    # some tests prefer to be run from their directory.\n    cmd = [sys.executable, \"-u\", scriptname] + cmdline_extras",
        "detail": ".venv.Scripts.pywin32_testall",
        "documentation": {}
    },
    {
        "label": "site_packages",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_testall",
        "description": ".venv.Scripts.pywin32_testall",
        "peekOfCode": "site_packages = [site.getusersitepackages()] + site.getsitepackages()\nfailures = []\n# Run a test using subprocess and wait for the result.\n# If we get an returncode != 0, we know that there was an error, but we don't\n# abort immediately - we run as many tests as we can.\ndef run_test(script, cmdline_extras):\n    dirname, scriptname = os.path.split(script)\n    # some tests prefer to be run from their directory.\n    cmd = [sys.executable, \"-u\", scriptname] + cmdline_extras\n    print(\"--- Running '%s' ---\" % script)",
        "detail": ".venv.Scripts.pywin32_testall",
        "documentation": {}
    },
    {
        "label": "failures",
        "kind": 5,
        "importPath": ".venv.Scripts.pywin32_testall",
        "description": ".venv.Scripts.pywin32_testall",
        "peekOfCode": "failures = []\n# Run a test using subprocess and wait for the result.\n# If we get an returncode != 0, we know that there was an error, but we don't\n# abort immediately - we run as many tests as we can.\ndef run_test(script, cmdline_extras):\n    dirname, scriptname = os.path.split(script)\n    # some tests prefer to be run from their directory.\n    cmd = [sys.executable, \"-u\", scriptname] + cmdline_extras\n    print(\"--- Running '%s' ---\" % script)\n    sys.stdout.flush()",
        "detail": ".venv.Scripts.pywin32_testall",
        "documentation": {}
    },
    {
        "label": "DispatchError",
        "kind": 6,
        "importPath": "dispatcher.dispatch_client",
        "description": "dispatcher.dispatch_client",
        "peekOfCode": "class DispatchError(Exception):\n    pass\nclass DispatchResult(BaseModel):\n    message_id: str\n    extracted: Dict[str, Any]\n    decision: Dict[str, Any]\n    actions: list\nasync def send_for_analysis(\n    *,\n    message_id: str,",
        "detail": "dispatcher.dispatch_client",
        "documentation": {}
    },
    {
        "label": "DispatchResult",
        "kind": 6,
        "importPath": "dispatcher.dispatch_client",
        "description": "dispatcher.dispatch_client",
        "peekOfCode": "class DispatchResult(BaseModel):\n    message_id: str\n    extracted: Dict[str, Any]\n    decision: Dict[str, Any]\n    actions: list\nasync def send_for_analysis(\n    *,\n    message_id: str,\n    text: str,\n    chat_id: Optional[str] = None,",
        "detail": "dispatcher.dispatch_client",
        "documentation": {}
    },
    {
        "label": "DISPATCH_URL",
        "kind": 5,
        "importPath": "dispatcher.dispatch_client",
        "description": "dispatcher.dispatch_client",
        "peekOfCode": "DISPATCH_URL = os.getenv(\"DISPATCH_URL\", \"http://192.168.1.223:8888/api/v1/dispatch/analyze\")\nDISPATCH_API_KEY = os.getenv(\"DISPATCH_API_KEY\", \"66fBbZsL72\")\nclass DispatchError(Exception):\n    pass\nclass DispatchResult(BaseModel):\n    message_id: str\n    extracted: Dict[str, Any]\n    decision: Dict[str, Any]\n    actions: list\nasync def send_for_analysis(",
        "detail": "dispatcher.dispatch_client",
        "documentation": {}
    },
    {
        "label": "DISPATCH_API_KEY",
        "kind": 5,
        "importPath": "dispatcher.dispatch_client",
        "description": "dispatcher.dispatch_client",
        "peekOfCode": "DISPATCH_API_KEY = os.getenv(\"DISPATCH_API_KEY\", \"66fBbZsL72\")\nclass DispatchError(Exception):\n    pass\nclass DispatchResult(BaseModel):\n    message_id: str\n    extracted: Dict[str, Any]\n    decision: Dict[str, Any]\n    actions: list\nasync def send_for_analysis(\n    *,",
        "detail": "dispatcher.dispatch_client",
        "documentation": {}
    },
    {
        "label": "load_previous_text",
        "kind": 2,
        "importPath": "find_message",
        "description": "find_message",
        "peekOfCode": "def load_previous_text(file_name='previous_text.txt'):\n    log_and_print(f\"Загрузка предыдущего текста из файла {file_name}\")\n    if os.path.exists(file_name):\n        try:\n            with open(file_name, 'r', encoding='utf-8') as f:\n                text = f.read()\n            log_and_print(f\"Предыдущий текст успешно загружен text = {text}\")\n            return text\n        except Exception as e:\n            log_and_print(f\"Ошибка при чтении файла {file_name}: {e}\")",
        "detail": "find_message",
        "documentation": {}
    },
    {
        "label": "remove_service_symbols_and_spaces",
        "kind": 2,
        "importPath": "find_message",
        "description": "find_message",
        "peekOfCode": "def remove_service_symbols_and_spaces(text):\n    # This will remove all non-alphanumeric characters and spaces\n    cleaned_text = re.sub(r'[^A-Za-z0-9]', '', text)\n    return cleaned_text\ndef save_current_text(text, file_name='previous_text.txt', max_chars=read_setting(\"max_chars_member\")):\n    log_and_print(f\"Adding current text to file {file_name} with a limit of {max_chars} characters.\")\n    try:\n        # Read existing content if the file exists\n        try:\n            with open(file_name, 'r', encoding='utf-8') as f:",
        "detail": "find_message",
        "documentation": {}
    },
    {
        "label": "save_current_text",
        "kind": 2,
        "importPath": "find_message",
        "description": "find_message",
        "peekOfCode": "def save_current_text(text, file_name='previous_text.txt', max_chars=read_setting(\"max_chars_member\")):\n    log_and_print(f\"Adding current text to file {file_name} with a limit of {max_chars} characters.\")\n    try:\n        # Read existing content if the file exists\n        try:\n            with open(file_name, 'r', encoding='utf-8') as f:\n                existing_content = f.read().strip()\n        except FileNotFoundError:\n            existing_content = \"\"\n        # Clean the new text",
        "detail": "find_message",
        "documentation": {}
    },
    {
        "label": "load_json",
        "kind": 2,
        "importPath": "init",
        "description": "init",
        "peekOfCode": "def load_json(file_path):\n    log_and_print(f\"Загрузка данных из JSON файла {file_path}.\", 'info')\n    try:\n        with open(file_path, 'r', encoding='utf-8') as file:\n            data = json.load(file)\n        log_and_print(f\"Данные успешно загружены из {file_path}.\", 'info')\n        return data\n    except FileNotFoundError:\n        log_and_print(f\"Файл {file_path} не найден.\", 'error')\n        return None",
        "detail": "init",
        "documentation": {}
    },
    {
        "label": "init",
        "kind": 2,
        "importPath": "init",
        "description": "init",
        "peekOfCode": "def init():\n    global tg_creds\n    global tg_channels\n    global settings\n    creds = load_json('creds.json')\n    tg_creds = creds.get('tg_creds', {})\n    log_and_print(f\"tg_creds {tg_creds}.\", 'info')\n    tg_channels = load_json('tg_channels.json')\n    log_and_print(f\"tg_channels {tg_channels}.\", 'info')\n    settings = load_json('settings.json')",
        "detail": "init",
        "documentation": {}
    },
    {
        "label": "tg_creds",
        "kind": 5,
        "importPath": "init",
        "description": "init",
        "peekOfCode": "tg_creds = None\ntg_channels = None\nsettings = None\ndef load_json(file_path):\n    log_and_print(f\"Загрузка данных из JSON файла {file_path}.\", 'info')\n    try:\n        with open(file_path, 'r', encoding='utf-8') as file:\n            data = json.load(file)\n        log_and_print(f\"Данные успешно загружены из {file_path}.\", 'info')\n        return data",
        "detail": "init",
        "documentation": {}
    },
    {
        "label": "tg_channels",
        "kind": 5,
        "importPath": "init",
        "description": "init",
        "peekOfCode": "tg_channels = None\nsettings = None\ndef load_json(file_path):\n    log_and_print(f\"Загрузка данных из JSON файла {file_path}.\", 'info')\n    try:\n        with open(file_path, 'r', encoding='utf-8') as file:\n            data = json.load(file)\n        log_and_print(f\"Данные успешно загружены из {file_path}.\", 'info')\n        return data\n    except FileNotFoundError:",
        "detail": "init",
        "documentation": {}
    },
    {
        "label": "settings",
        "kind": 5,
        "importPath": "init",
        "description": "init",
        "peekOfCode": "settings = None\ndef load_json(file_path):\n    log_and_print(f\"Загрузка данных из JSON файла {file_path}.\", 'info')\n    try:\n        with open(file_path, 'r', encoding='utf-8') as file:\n            data = json.load(file)\n        log_and_print(f\"Данные успешно загружены из {file_path}.\", 'info')\n        return data\n    except FileNotFoundError:\n        log_and_print(f\"Файл {file_path} не найден.\", 'error')",
        "detail": "init",
        "documentation": {}
    },
    {
        "label": "log_and_print",
        "kind": 2,
        "importPath": "log",
        "description": "log",
        "peekOfCode": "def log_and_print(message, level='info'):\n    current_time = datetime.now().strftime('%Y-%m-%d %H:%M:%S')\n    print(f\"[{current_time}] {message}\")\n    # if level == 'info':\n    #     logging.info(message)\n    # elif level == 'warning':\n    #     log_and_print(message)\n    # elif level == 'error':\n    #     log_and_print(message)",
        "detail": "log",
        "documentation": {}
    },
    {
        "label": "RECT",
        "kind": 6,
        "importPath": "paint",
        "description": "paint",
        "peekOfCode": "class RECT(ctypes.Structure):\n    _fields_ = [(\"left\", ctypes.c_long),\n                (\"top\", ctypes.c_long),\n                (\"right\", ctypes.c_long),\n                (\"bottom\", ctypes.c_long)]\ndef create_colorref(red, green, blue):\n    \"\"\"\n    Преобразует RGB в COLORREF.\n    \"\"\"\n    return (blue << 16) | (green << 8) | red",
        "detail": "paint",
        "documentation": {}
    },
    {
        "label": "create_colorref",
        "kind": 2,
        "importPath": "paint",
        "description": "paint",
        "peekOfCode": "def create_colorref(red, green, blue):\n    \"\"\"\n    Преобразует RGB в COLORREF.\n    \"\"\"\n    return (blue << 16) | (green << 8) | red\ndef show_position(x, y, duration=2, size=50, color=\"red\"):\n    \"\"\"\n    Показывает положение на экране с использованием Tkinter.\n    :param x: Координата X для позиционирования окна.\n    :param y: Координата Y для позиционирования окна.",
        "detail": "paint",
        "documentation": {}
    },
    {
        "label": "show_position",
        "kind": 2,
        "importPath": "paint",
        "description": "paint",
        "peekOfCode": "def show_position(x, y, duration=2, size=50, color=\"red\"):\n    \"\"\"\n    Показывает положение на экране с использованием Tkinter.\n    :param x: Координата X для позиционирования окна.\n    :param y: Координата Y для позиционирования окна.\n    :param duration: Длительность показа окна в секундах.\n    :param size: Размер окна (ширина и высота).\n    :param color: Цвет фона окна.\n    \"\"\"\n    root = tk.Tk()",
        "detail": "paint",
        "documentation": {}
    },
    {
        "label": "get_image_height",
        "kind": 2,
        "importPath": "paint",
        "description": "paint",
        "peekOfCode": "def get_image_height(file_path):\n    \"\"\"\n    Determines the height of an image file.\n    Args:\n        file_path (str): Path to the image file.\n    Returns:\n        int: Height of the image in pixels.\n    \"\"\"\n    try:\n        # Open the image file",
        "detail": "paint",
        "documentation": {}
    },
    {
        "label": "SW_SHOW",
        "kind": 5,
        "importPath": "paint",
        "description": "paint",
        "peekOfCode": "SW_SHOW = 5\nWS_POPUP = 0x80000000\nWS_VISIBLE = 0x10000000\nWS_EX_TOPMOST = 0x00000008\nWS_EX_LAYERED = 0x00080000\nLWA_COLORKEY = 0x00000001\nHWND_TOPMOST = -1\nSWP_NOSIZE = 0x0001\nSWP_NOMOVE = 0x0002\nSWP_NOACTIVATE = 0x0010",
        "detail": "paint",
        "documentation": {}
    },
    {
        "label": "WS_POPUP",
        "kind": 5,
        "importPath": "paint",
        "description": "paint",
        "peekOfCode": "WS_POPUP = 0x80000000\nWS_VISIBLE = 0x10000000\nWS_EX_TOPMOST = 0x00000008\nWS_EX_LAYERED = 0x00080000\nLWA_COLORKEY = 0x00000001\nHWND_TOPMOST = -1\nSWP_NOSIZE = 0x0001\nSWP_NOMOVE = 0x0002\nSWP_NOACTIVATE = 0x0010\nclass RECT(ctypes.Structure):",
        "detail": "paint",
        "documentation": {}
    },
    {
        "label": "WS_VISIBLE",
        "kind": 5,
        "importPath": "paint",
        "description": "paint",
        "peekOfCode": "WS_VISIBLE = 0x10000000\nWS_EX_TOPMOST = 0x00000008\nWS_EX_LAYERED = 0x00080000\nLWA_COLORKEY = 0x00000001\nHWND_TOPMOST = -1\nSWP_NOSIZE = 0x0001\nSWP_NOMOVE = 0x0002\nSWP_NOACTIVATE = 0x0010\nclass RECT(ctypes.Structure):\n    _fields_ = [(\"left\", ctypes.c_long),",
        "detail": "paint",
        "documentation": {}
    },
    {
        "label": "WS_EX_TOPMOST",
        "kind": 5,
        "importPath": "paint",
        "description": "paint",
        "peekOfCode": "WS_EX_TOPMOST = 0x00000008\nWS_EX_LAYERED = 0x00080000\nLWA_COLORKEY = 0x00000001\nHWND_TOPMOST = -1\nSWP_NOSIZE = 0x0001\nSWP_NOMOVE = 0x0002\nSWP_NOACTIVATE = 0x0010\nclass RECT(ctypes.Structure):\n    _fields_ = [(\"left\", ctypes.c_long),\n                (\"top\", ctypes.c_long),",
        "detail": "paint",
        "documentation": {}
    },
    {
        "label": "WS_EX_LAYERED",
        "kind": 5,
        "importPath": "paint",
        "description": "paint",
        "peekOfCode": "WS_EX_LAYERED = 0x00080000\nLWA_COLORKEY = 0x00000001\nHWND_TOPMOST = -1\nSWP_NOSIZE = 0x0001\nSWP_NOMOVE = 0x0002\nSWP_NOACTIVATE = 0x0010\nclass RECT(ctypes.Structure):\n    _fields_ = [(\"left\", ctypes.c_long),\n                (\"top\", ctypes.c_long),\n                (\"right\", ctypes.c_long),",
        "detail": "paint",
        "documentation": {}
    },
    {
        "label": "LWA_COLORKEY",
        "kind": 5,
        "importPath": "paint",
        "description": "paint",
        "peekOfCode": "LWA_COLORKEY = 0x00000001\nHWND_TOPMOST = -1\nSWP_NOSIZE = 0x0001\nSWP_NOMOVE = 0x0002\nSWP_NOACTIVATE = 0x0010\nclass RECT(ctypes.Structure):\n    _fields_ = [(\"left\", ctypes.c_long),\n                (\"top\", ctypes.c_long),\n                (\"right\", ctypes.c_long),\n                (\"bottom\", ctypes.c_long)]",
        "detail": "paint",
        "documentation": {}
    },
    {
        "label": "HWND_TOPMOST",
        "kind": 5,
        "importPath": "paint",
        "description": "paint",
        "peekOfCode": "HWND_TOPMOST = -1\nSWP_NOSIZE = 0x0001\nSWP_NOMOVE = 0x0002\nSWP_NOACTIVATE = 0x0010\nclass RECT(ctypes.Structure):\n    _fields_ = [(\"left\", ctypes.c_long),\n                (\"top\", ctypes.c_long),\n                (\"right\", ctypes.c_long),\n                (\"bottom\", ctypes.c_long)]\ndef create_colorref(red, green, blue):",
        "detail": "paint",
        "documentation": {}
    },
    {
        "label": "SWP_NOSIZE",
        "kind": 5,
        "importPath": "paint",
        "description": "paint",
        "peekOfCode": "SWP_NOSIZE = 0x0001\nSWP_NOMOVE = 0x0002\nSWP_NOACTIVATE = 0x0010\nclass RECT(ctypes.Structure):\n    _fields_ = [(\"left\", ctypes.c_long),\n                (\"top\", ctypes.c_long),\n                (\"right\", ctypes.c_long),\n                (\"bottom\", ctypes.c_long)]\ndef create_colorref(red, green, blue):\n    \"\"\"",
        "detail": "paint",
        "documentation": {}
    },
    {
        "label": "SWP_NOMOVE",
        "kind": 5,
        "importPath": "paint",
        "description": "paint",
        "peekOfCode": "SWP_NOMOVE = 0x0002\nSWP_NOACTIVATE = 0x0010\nclass RECT(ctypes.Structure):\n    _fields_ = [(\"left\", ctypes.c_long),\n                (\"top\", ctypes.c_long),\n                (\"right\", ctypes.c_long),\n                (\"bottom\", ctypes.c_long)]\ndef create_colorref(red, green, blue):\n    \"\"\"\n    Преобразует RGB в COLORREF.",
        "detail": "paint",
        "documentation": {}
    },
    {
        "label": "SWP_NOACTIVATE",
        "kind": 5,
        "importPath": "paint",
        "description": "paint",
        "peekOfCode": "SWP_NOACTIVATE = 0x0010\nclass RECT(ctypes.Structure):\n    _fields_ = [(\"left\", ctypes.c_long),\n                (\"top\", ctypes.c_long),\n                (\"right\", ctypes.c_long),\n                (\"bottom\", ctypes.c_long)]\ndef create_colorref(red, green, blue):\n    \"\"\"\n    Преобразует RGB в COLORREF.\n    \"\"\"",
        "detail": "paint",
        "documentation": {}
    },
    {
        "label": "Context",
        "kind": 6,
        "importPath": "pwa",
        "description": "pwa",
        "peekOfCode": "class Context:\n    def __init__(self, bot_client, name_viber, channels, channel_names, old_text,\n                 width_menu=190,\n                 height_menu=220,\n                 height_item_menu=20,\n                 x_offset_out_mess=400,\n                 search_board_mess_x_start=360,\n                 search_board_mess_x_end=1000,\n                 search_board_mess_y_start=100,\n                 search_board_mess_y_end=1000,",
        "detail": "pwa",
        "documentation": {}
    },
    {
        "label": "get_image_hash",
        "kind": 2,
        "importPath": "pwa",
        "description": "pwa",
        "peekOfCode": "def get_image_hash(image, size=(8, 8)):\n    \"\"\"\n    Возвращает хэш для изображения, снижая его разрешение до size\n    и переводя в градации серого. Подходит для быстрого сравнения изображений.\n    Параметры:\n    - image: объект PIL.Image или любой формат, который PIL может прочитать\n      (BytesIO, путь к файлу)\n    - size: кортеж (ширина, высота) для уменьшения изображения\n    Возвращает:\n    - строку с хэшем (hex-формат)",
        "detail": "pwa",
        "documentation": {}
    },
    {
        "label": "fill_y_mess",
        "kind": 2,
        "importPath": "pwa",
        "description": "pwa",
        "peekOfCode": "def fill_y_mess(window, s):\n    s.y_mess = []\n    window.set_focus()\n    log_and_print(f\"Старт fill_y_mess\")\n    height = s.search_board_mess_y_end - s.search_board_mess_y_start\n    width = s.search_board_mess_x_end - s.search_board_mess_x_start\n    x, y = s.search_board_mess_x_start, s.search_board_mess_y_start\n    log_and_print(f\"x = {x} y = {y} height = {height}, width = {width}\")\n    region = [x,y, width, height]\n    #coordinates = capture_and_find_text_coordinates(region, read_setting(\"word_comment\"), visualize = read_setting(\"visualize\"))",
        "detail": "pwa",
        "documentation": {}
    },
    {
        "label": "fill_y_mess_care_find",
        "kind": 2,
        "importPath": "pwa",
        "description": "pwa",
        "peekOfCode": "def fill_y_mess_care_find(window, s):\n    s.y_mess = []\n    window.set_focus()\n    log_and_print(f\"[fill_y_mess_care_find] Старт fill_y_mess ретельного пошуку\")\n    x, y, height = s.search_board_mess_x_start, s.search_board_mess_y_end, s.search_board_mess_y_end - s.search_board_mess_y_start\n    left_click(x + s.x_offset_out_mess, y - 100)\n    log_and_print(f\"[fill_y_mess_care_find] x = {x} y = {y} height = {height}\")\n    comment_height = read_setting(\"comment_height\")\n    comment_width = read_setting(\"comment_width\")\n    stop = False",
        "detail": "pwa",
        "documentation": {}
    },
    {
        "label": "SWP_NOSIZE",
        "kind": 5,
        "importPath": "pwa",
        "description": "pwa",
        "peekOfCode": "SWP_NOSIZE = 0x0001\nSWP_NOMOVE = 0x0002\nSWP_NOACTIVATE = 0x0010\nSWP_DRAWFRAME = 0x0020\ns = {}\ncount_y_mess_empty = 0\ndef get_image_hash(image, size=(8, 8)):\n    \"\"\"\n    Возвращает хэш для изображения, снижая его разрешение до size\n    и переводя в градации серого. Подходит для быстрого сравнения изображений.",
        "detail": "pwa",
        "documentation": {}
    },
    {
        "label": "SWP_NOMOVE",
        "kind": 5,
        "importPath": "pwa",
        "description": "pwa",
        "peekOfCode": "SWP_NOMOVE = 0x0002\nSWP_NOACTIVATE = 0x0010\nSWP_DRAWFRAME = 0x0020\ns = {}\ncount_y_mess_empty = 0\ndef get_image_hash(image, size=(8, 8)):\n    \"\"\"\n    Возвращает хэш для изображения, снижая его разрешение до size\n    и переводя в градации серого. Подходит для быстрого сравнения изображений.\n    Параметры:",
        "detail": "pwa",
        "documentation": {}
    },
    {
        "label": "SWP_NOACTIVATE",
        "kind": 5,
        "importPath": "pwa",
        "description": "pwa",
        "peekOfCode": "SWP_NOACTIVATE = 0x0010\nSWP_DRAWFRAME = 0x0020\ns = {}\ncount_y_mess_empty = 0\ndef get_image_hash(image, size=(8, 8)):\n    \"\"\"\n    Возвращает хэш для изображения, снижая его разрешение до size\n    и переводя в градации серого. Подходит для быстрого сравнения изображений.\n    Параметры:\n    - image: объект PIL.Image или любой формат, который PIL может прочитать",
        "detail": "pwa",
        "documentation": {}
    },
    {
        "label": "SWP_DRAWFRAME",
        "kind": 5,
        "importPath": "pwa",
        "description": "pwa",
        "peekOfCode": "SWP_DRAWFRAME = 0x0020\ns = {}\ncount_y_mess_empty = 0\ndef get_image_hash(image, size=(8, 8)):\n    \"\"\"\n    Возвращает хэш для изображения, снижая его разрешение до size\n    и переводя в градации серого. Подходит для быстрого сравнения изображений.\n    Параметры:\n    - image: объект PIL.Image или любой формат, который PIL может прочитать\n      (BytesIO, путь к файлу)",
        "detail": "pwa",
        "documentation": {}
    },
    {
        "label": "s",
        "kind": 5,
        "importPath": "pwa",
        "description": "pwa",
        "peekOfCode": "s = {}\ncount_y_mess_empty = 0\ndef get_image_hash(image, size=(8, 8)):\n    \"\"\"\n    Возвращает хэш для изображения, снижая его разрешение до size\n    и переводя в градации серого. Подходит для быстрого сравнения изображений.\n    Параметры:\n    - image: объект PIL.Image или любой формат, который PIL может прочитать\n      (BytesIO, путь к файлу)\n    - size: кортеж (ширина, высота) для уменьшения изображения",
        "detail": "pwa",
        "documentation": {}
    },
    {
        "label": "count_y_mess_empty",
        "kind": 5,
        "importPath": "pwa",
        "description": "pwa",
        "peekOfCode": "count_y_mess_empty = 0\ndef get_image_hash(image, size=(8, 8)):\n    \"\"\"\n    Возвращает хэш для изображения, снижая его разрешение до size\n    и переводя в градации серого. Подходит для быстрого сравнения изображений.\n    Параметры:\n    - image: объект PIL.Image или любой формат, который PIL может прочитать\n      (BytesIO, путь к файлу)\n    - size: кортеж (ширина, высота) для уменьшения изображения\n    Возвращает:",
        "detail": "pwa",
        "documentation": {}
    },
    {
        "label": "filter_recognized_text",
        "kind": 2,
        "importPath": "recognize_text",
        "description": "recognize_text",
        "peekOfCode": "def filter_recognized_text(text):\n    \"\"\"\n    Filters out lines that are shorter than 6 characters and contain colons.\n    \"\"\"\n    lines = text.split('\\n')  # Разбиваем текст на строки\n    filtered_lines = []\n    for line in lines:\n        stripped_line = line.strip()  # Убираем пробелы в начале и конце строки\n        if len(stripped_line) < 6 and ':' in stripped_line:\n            continue  # Пропускаем строки, если их длина < 6 и они содержат двоеточие",
        "detail": "recognize_text",
        "documentation": {}
    },
    {
        "label": "capture_and_recognize",
        "kind": 2,
        "importPath": "recognize_text",
        "description": "recognize_text",
        "peekOfCode": "def capture_and_recognize(region):\n    log_and_print(f\"[capture_and_recognize] region: {region}\")\n    \"\"\"Capture and recognize text only when the image changes.\"\"\"\n    try:\n        # Take a screenshot\n        #screenshot = pyautogui.screenshot(region=region)\n        screenshot = take_screenshot(region)\n        #showImage(screenshot, region)\n        # Preprocess the image (if needed)\n        processed_image = preprocess_image(screenshot) #",
        "detail": "recognize_text",
        "documentation": {}
    },
    {
        "label": "capture_and_find_multiple_text_coordinates",
        "kind": 2,
        "importPath": "recognize_text",
        "description": "recognize_text",
        "peekOfCode": "def capture_and_find_multiple_text_coordinates(region, search_phrases, visualize = False):\n    log_and_print(f\"[capture_and_find_multiple_text_coordinates] region: {region}, search_phrases: {search_phrases}\")\n    try:\n        cv2.destroyAllWindows()\n        # Захват скриншота\n        screenshot_np = take_screenshot(region)\n        log_and_print(f\"[capture_and_find_text_coordinates] Скриншот захвачен успешно.\")\n        # Предварительная обработка изображения\n        processed_image = preprocess_image(screenshot_np)\n        log_and_print(f\"[capture_and_find_text_coordinates] Изображение обработано успешно.\")",
        "detail": "recognize_text",
        "documentation": {}
    },
    {
        "label": "preprocess_image",
        "kind": 2,
        "importPath": "recognize_text",
        "description": "recognize_text",
        "peekOfCode": "def preprocess_image(image_np):\n    # Проверяем размерность массива\n    if len(image_np.shape) != 3 or image_np.shape[2] != 3:\n        raise ValueError(\"Изображение должно быть цветным (3 канала).\")\n    # Конвертируем из RGB в BGR\n    image_bgr = cv2.cvtColor(image_np, cv2.COLOR_RGB2BGR)\n    # Конвертируем в оттенки серого\n    gray = cv2.cvtColor(image_bgr, cv2.COLOR_BGR2GRAY)\n    # Улучшаем контрастность с помощью CLAHE (Contrast Limited Adaptive Histogram Equalization)\n    clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8, 8))",
        "detail": "recognize_text",
        "documentation": {}
    },
    {
        "label": "perform_ocr_with_positions",
        "kind": 2,
        "importPath": "recognize_text",
        "description": "recognize_text",
        "peekOfCode": "def perform_ocr_with_positions(image):\n    custom_config = read_setting(\"capture_and_recognize.custom_config\")\n    lang = read_setting(\"capture_and_recognize.lang\")\n    data = pytesseract.image_to_data(image, lang=lang, config=custom_config, output_type=Output.DICT)\n    n_boxes = len(data['level'])\n    words_with_positions = []\n    for i in range(n_boxes):\n        if int(data['conf'][i]) > 60 and data['text'][i].strip() != \"\":\n            word_info = {\n                'text': data['text'][i],",
        "detail": "recognize_text",
        "documentation": {}
    },
    {
        "label": "visualize_ocr_results",
        "kind": 2,
        "importPath": "recognize_text",
        "description": "recognize_text",
        "peekOfCode": "def visualize_ocr_results(image, ocr_data):\n    \"\"\"\n    Отображает распознанные слова с их позициями на изображении.\n    :param image: Обработанное изображение (оттенки серого)\n    :param ocr_data: Список слов с их позициями\n    \"\"\"\n    # Конвертируем обратно в BGR для отображения цветных рамок\n    image_bgr = cv2.cvtColor(image, cv2.COLOR_GRAY2BGR)\n    for word in ocr_data:\n        # Рисуем прямоугольник вокруг слова",
        "detail": "recognize_text",
        "documentation": {}
    },
    {
        "label": "capture_and_find_text_coordinates",
        "kind": 2,
        "importPath": "recognize_text",
        "description": "recognize_text",
        "peekOfCode": "def capture_and_find_text_coordinates(region, search_words, preprocess=True, case_sensitive=False, visualize = False):\n    try:\n        # Захват скриншота\n        screenshot_np = take_screenshot(region)\n        log_and_print(f\"[capture_and_find_text_coordinates] Скриншот захвачен успешно.\")\n        if preprocess :\n            # Предварительная обработка изображения\n            processed_image = preprocess_image(screenshot_np)\n            log_and_print(f\"[capture_and_find_text_coordinates] Изображение обработано успешно.\")\n        else:",
        "detail": "recognize_text",
        "documentation": {}
    },
    {
        "label": "find_text_upward_with_highlight",
        "kind": 2,
        "importPath": "recognize_text",
        "description": "recognize_text",
        "peekOfCode": "def find_text_upward_with_highlight(start_x, start_y, y_max, height, template_height, template_width, search_words):\n    step = int(template_height / 2)  # Шаг поиска\n    current_y = start_y\n    min_y = y_max - height\n    log_and_print(f\"height = {height}, min_y = {min_y}\")\n    while current_y >= min_y:\n        log_and_print(f\"start_x = {start_x}, current_y = {current_y}, min_y = {min_y}\")\n        # Снимаем скриншот текущей области\n        region = (start_x, current_y, template_width, template_height)\n        text = capture_and_recognize(region).lower()",
        "detail": "recognize_text",
        "documentation": {}
    },
    {
        "label": "pytesseract.pytesseract.tesseract_cmd",
        "kind": 5,
        "importPath": "recognize_text",
        "description": "recognize_text",
        "peekOfCode": "pytesseract.pytesseract.tesseract_cmd = r'C:\\Program Files\\Tesseract-OCR\\tesseract.exe'\nimport cv2\ndef filter_recognized_text(text):\n    \"\"\"\n    Filters out lines that are shorter than 6 characters and contain colons.\n    \"\"\"\n    lines = text.split('\\n')  # Разбиваем текст на строки\n    filtered_lines = []\n    for line in lines:\n        stripped_line = line.strip()  # Убираем пробелы в начале и конце строки",
        "detail": "recognize_text",
        "documentation": {}
    },
    {
        "label": "ScreenRegionSelector",
        "kind": 6,
        "importPath": "ScreenRegionSelector",
        "description": "ScreenRegionSelector",
        "peekOfCode": "class ScreenRegionSelector:\n    def __init__(self):\n        self.root = tk.Tk()\n        # Полноэкранное окно и полупрозрачность\n        self.root.attributes(\"-fullscreen\", True)  # Окно на весь экран\n        self.root.attributes(\"-alpha\", 0.5)  # Полупрозрачность\n        self.root.config(cursor=\"crosshair\")  # Курсор в виде крестика\n        # Окно всегда поверх других окон\n        self.root.attributes(\"-topmost\", True)\n        self.canvas = tk.Canvas(self.root, cursor=\"crosshair\")",
        "detail": "ScreenRegionSelector",
        "documentation": {}
    },
    {
        "label": "read_region_from_json",
        "kind": 2,
        "importPath": "screen_region",
        "description": "screen_region",
        "peekOfCode": "def read_region_from_json(json_file='region.json'):\n    log_and_print(f\"Чтение области экрана из файла {json_file}\")\n    try:\n        with open(json_file, 'r') as f:\n            data = json.load(f)\n        left = data['left']\n        top = data['top']\n        width = data['width']\n        height = data['height']\n        log_and_print(f\"Считанная область из JSON: left={left}, top={top}, width={width}, height={height}\")",
        "detail": "screen_region",
        "documentation": {}
    },
    {
        "label": "save_region_to_json",
        "kind": 2,
        "importPath": "screen_region",
        "description": "screen_region",
        "peekOfCode": "def save_region_to_json(left, top, width, height, json_file='region.json'):\n    log_and_print(f\"Сохранение области экрана в файл {json_file}\")\n    try:\n        data = {'left': left, 'top': top, 'width': width, 'height': height}\n        with open(json_file, 'w') as f:\n            json.dump(data, f)\n        log_and_print(f\"Новая область сохранена в файл {json_file}\")\n    except Exception as e:\n        log_and_print(f\"Ошибка при сохранении области экрана в файл {json_file}: {e}\")\ndef draw_rectangle_on_screen(left, top, width, height):",
        "detail": "screen_region",
        "documentation": {}
    },
    {
        "label": "draw_rectangle_on_screen",
        "kind": 2,
        "importPath": "screen_region",
        "description": "screen_region",
        "peekOfCode": "def draw_rectangle_on_screen(left, top, width, height):\n    log_and_print(\"Рисование прямоугольника на экране\")\n    try:\n        root = tk.Tk()\n        root.overrideredirect(True)\n        root.geometry(f\"{width}x{height}+{left}+{top}\")\n        root.lift()\n        root.wm_attributes(\"-topmost\", True)\n        # Попытка установить прозрачность окна\n        try:",
        "detail": "screen_region",
        "documentation": {}
    },
    {
        "label": "select_region",
        "kind": 2,
        "importPath": "screen_region",
        "description": "screen_region",
        "peekOfCode": "def select_region():\n    # Функция для выбора области экрана с помощью мыши\n    log_and_print(\"Пожалуйста, выберите новую область экрана\")\n    root = tk.Tk()\n    root.attributes(\"-topmost\", True)\n    root.attributes(\"-fullscreen\", True)\n    root.attributes(\"-alpha\", 0.2)\n    root.configure(background='black')\n    canvas = tk.Canvas(root, cursor=\"crosshair\", bg='black')\n    canvas.pack(fill=tk.BOTH, expand=True)",
        "detail": "screen_region",
        "documentation": {}
    },
    {
        "label": "processed_messages",
        "kind": 5,
        "importPath": "tg",
        "description": "tg",
        "peekOfCode": "processed_messages = set()\n# Семафор для последовательной обработки сообщений\nprocessing_semaphore = asyncio.Semaphore(1)\ntelegram_channel_name = None\ntelegram_channel_id = None\nasync def send_message_to_tg_channel(bot_client, channel_name, message_text, file_path=None):\n    try:\n        # Получаем объект канала\n        channel_entity = await bot_client.get_entity(channel_name)\n        # Отправка сообщения с изображением или только текста",
        "detail": "tg",
        "documentation": {}
    },
    {
        "label": "processing_semaphore",
        "kind": 5,
        "importPath": "tg",
        "description": "tg",
        "peekOfCode": "processing_semaphore = asyncio.Semaphore(1)\ntelegram_channel_name = None\ntelegram_channel_id = None\nasync def send_message_to_tg_channel(bot_client, channel_name, message_text, file_path=None):\n    try:\n        # Получаем объект канала\n        channel_entity = await bot_client.get_entity(channel_name)\n        # Отправка сообщения с изображением или только текста\n        if file_path:\n            if not os.path.isfile(file_path):",
        "detail": "tg",
        "documentation": {}
    },
    {
        "label": "telegram_channel_name",
        "kind": 5,
        "importPath": "tg",
        "description": "tg",
        "peekOfCode": "telegram_channel_name = None\ntelegram_channel_id = None\nasync def send_message_to_tg_channel(bot_client, channel_name, message_text, file_path=None):\n    try:\n        # Получаем объект канала\n        channel_entity = await bot_client.get_entity(channel_name)\n        # Отправка сообщения с изображением или только текста\n        if file_path:\n            if not os.path.isfile(file_path):\n                log_and_print(f\"[send_message_to_tg_channel] Файл не найден: {file_path}\")",
        "detail": "tg",
        "documentation": {}
    },
    {
        "label": "telegram_channel_id",
        "kind": 5,
        "importPath": "tg",
        "description": "tg",
        "peekOfCode": "telegram_channel_id = None\nasync def send_message_to_tg_channel(bot_client, channel_name, message_text, file_path=None):\n    try:\n        # Получаем объект канала\n        channel_entity = await bot_client.get_entity(channel_name)\n        # Отправка сообщения с изображением или только текста\n        if file_path:\n            if not os.path.isfile(file_path):\n                log_and_print(f\"[send_message_to_tg_channel] Файл не найден: {file_path}\")\n                return",
        "detail": "tg",
        "documentation": {}
    },
    {
        "label": "preprocess_image",
        "kind": 2,
        "importPath": "utils",
        "description": "utils",
        "peekOfCode": "def preprocess_image(image_np):\n    \"\"\"\n    Преобразует изображение для улучшения качества OCR.\n    :param image_np: Изображение в формате NumPy массива (RGB)\n    :return: Обработанное изображение в оттенках серого\n    \"\"\"\n    # Проверяем размерность массива\n    if len(image_np.shape) != 3 or image_np.shape[2] != 3:\n        raise ValueError(\"Изображение должно быть цветным (3 канала).\")\n    # Конвертируем из RGB в BGR",
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "read_setting",
        "kind": 2,
        "importPath": "utils",
        "description": "utils",
        "peekOfCode": "def read_setting(field_path):\n    file_path = \"settings.json\"\n    try:\n        # Open and load the JSON file\n        with open(file_path, 'r', encoding='utf-8') as file:\n            settings = json.load(file)\n        # Navigate to the desired field\n        keys = field_path.split('.')\n        value = settings\n        for key in keys:",
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "write_setting",
        "kind": 2,
        "importPath": "utils",
        "description": "utils",
        "peekOfCode": "def write_setting(field_path, new_value):\n    \"\"\"\n    Writes a new value to a specific field in a JSON settings file.\n    :param field_path: Dot-separated path to the field (e.g., \"capture_and_recognize.lang\").\n    :param new_value: The new value to set for the specified field.\n    \"\"\"\n    file_path = \"settings.json\"\n    try:\n        # Open and load the JSON file\n        with open(file_path, 'r', encoding='utf-8') as file:",
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "load_json",
        "kind": 2,
        "importPath": "utils",
        "description": "utils",
        "peekOfCode": "def load_json(file_path):\n    log_and_print(f\"Загрузка данных из JSON файла {file_path}.\", 'info')\n    try:\n        with open(file_path, 'r', encoding='utf-8') as file:\n            data = json.load(file)\n        log_and_print(f\"Данные успешно загружены из {file_path}.\", 'info')\n        return data\n    except FileNotFoundError:\n        log_and_print(f\"Файл {file_path} не найден.\", 'error')\n        return None",
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "get_latest_file",
        "kind": 2,
        "importPath": "utils",
        "description": "utils",
        "peekOfCode": "def get_latest_file(download_folder):\n    try:\n        files = os.listdir(download_folder)\n        paths = [os.path.join(download_folder, fname) for fname in files]\n        latest_file = max(paths, key=os.path.getctime)\n        return latest_file\n    except Exception as e:\n        print(f\"Ошибка при получении последнего файла: {e}\")\n        return None\ndef is_video_file(file_path):",
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "is_video_file",
        "kind": 2,
        "importPath": "utils",
        "description": "utils",
        "peekOfCode": "def is_video_file(file_path):\n    \"\"\"\n    Определяет, является ли файл видео по его расширению.\n    :param file_path: Путь к файлу.\n    :return: True, если файл является видео, иначе False.\n    \"\"\"\n    # Список расширений видеофайлов\n    video_extensions = {\".mp4\", \".mkv\", \".avi\", \".mov\", \".wmv\", \".flv\", \".webm\", \".m4v\"}\n    # Получаем расширение файла\n    file_extension = file_path.lower().split('.')[-1]",
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "get_video_dimensions_cv2",
        "kind": 2,
        "importPath": "utils",
        "description": "utils",
        "peekOfCode": "def get_video_dimensions_cv2(file_path):\n    cap = cv2.VideoCapture(file_path)\n    if not cap.isOpened():\n        return None, None, None, None\n    width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))\n    height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))\n    fps = cap.get(cv2.CAP_PROP_FPS)\n    duration = cap.get(cv2.CAP_PROP_FRAME_COUNT) / fps if fps else None\n    cap.release()\n    return width, height, duration, fps",
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "showImage",
        "kind": 2,
        "importPath": "utils",
        "description": "utils",
        "peekOfCode": "def showImage(processed_image, ms):\n    # Отображение обработанного изображения\n    processed_array = np.array(processed_image)\n    window_name = \"Processed Image\"\n    cv2.namedWindow(window_name, cv2.WINDOW_NORMAL)\n    cv2.moveWindow(window_name, 10, 10)\n    cv2.imshow(window_name, processed_array)\n    cv2.waitKey(1)\n    cv2.waitKey(ms)\n    cv2.destroyAllWindows()",
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "draw_match_overlay",
        "kind": 2,
        "importPath": "utils",
        "description": "utils",
        "peekOfCode": "def draw_match_overlay(\n    img, x, y, w, h, *,\n    idx=None, score=None, y_boundary=None,\n    show_zoom=True, zoom_scale=2, zoom_size_min=120\n):\n    H, W = img.shape[:2]\n    bgr = img if img.ndim == 3 else cv2.cvtColor(img, cv2.COLOR_GRAY2BGR)\n    # 1) Bounding box (high contrast + anti-aliased)\n    cv2.rectangle(bgr, (x, y), (x+w, y+h), (0, 255, 0), 2, lineType=cv2.LINE_AA)\n    # 2) Top-left crosshair",
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "take_screenshot",
        "kind": 2,
        "importPath": "utils",
        "description": "utils",
        "peekOfCode": "def take_screenshot(region):\n    screenshot = pyautogui.screenshot(region=region)\n    image_np = np.array(screenshot)\n    return image_np\nimport cv2\nimport numpy as np\ndef _safe_show(img_bgr, delay_ms: int = 1000, win_name: str = \"Screen with region\"):\n    \"\"\"Use your showImage if available; otherwise fallback to cv2.imshow.\"\"\"\n    try:\n        showImage(img_bgr, delay_ms)  # your helper",
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "show_screen_with_region",
        "kind": 2,
        "importPath": "utils",
        "description": "utils",
        "peekOfCode": "def show_screen_with_region(\n    region,                      # (x, y, w, h) in screen coordinates\n    delay_ms: int = 1000,\n    border_color = (0, 255, 0),  # BGR\n    thickness: int = 3,\n    dim_background: bool = True  # darken non-selected area\n):\n    \"\"\"\n    Capture full screen, draw a rectangle around `region`, and display.\n    Region is highlighted on the *full-screen* image so you see where it is.",
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "ImageLike",
        "kind": 5,
        "importPath": "utils",
        "description": "utils",
        "peekOfCode": "ImageLike = Union[str, np.ndarray]\ndef preprocess_image(image_np):\n    \"\"\"\n    Преобразует изображение для улучшения качества OCR.\n    :param image_np: Изображение в формате NumPy массива (RGB)\n    :return: Обработанное изображение в оттенках серого\n    \"\"\"\n    # Проверяем размерность массива\n    if len(image_np.shape) != 3 or image_np.shape[2] != 3:\n        raise ValueError(\"Изображение должно быть цветным (3 канала).\")",
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "old_text",
        "kind": 5,
        "importPath": "vb",
        "description": "vb",
        "peekOfCode": "old_text = \"\"\nasync def main():\n    global bot_client\n    new_text = \"\"\n    log_and_print(\"Запуск программы\")\n    # Load initial region from JSON\n    left, top, width, height = read_region_from_json()\n    region = [left, top, width, height]\n    log_and_print(f\"Область для захвата: {region}\")\n    # Draw the initial rectangle on screen",
        "detail": "vb",
        "documentation": {}
    },
    {
        "label": "scroll_with_mouse",
        "kind": 2,
        "importPath": "vb_utils",
        "description": "vb_utils",
        "peekOfCode": "def scroll_with_mouse(window, count_scroll, direction=\"down\"):\n    window.set_focus()\n    # Находим панель с сообщениями\n    chat_pane = window.child_window(control_type=\"Pane\", found_index=0)\n    # Получаем координаты панели\n    rect = chat_pane.rectangle()\n    center_x = (rect.left + rect.right) // 2\n    center_y = (rect.top + rect.bottom) // 2\n    # Прокручиваем вниз\n    for _ in range(count_scroll):  # Повторяем несколько раз",
        "detail": "vb_utils",
        "documentation": {}
    },
    {
        "label": "right_click_on_panel",
        "kind": 2,
        "importPath": "vb_utils",
        "description": "vb_utils",
        "peekOfCode": "def right_click_on_panel(x_offset=0, y_offset=0):\n    \"\"\"\n    Кликает правой кнопкой мыши на панели с сообщениями Viber.\n    :param x_offset: Смещение по X относительно центра панели.\n    :param y_offset: Смещение по Y относительно центра панели.\n    \"\"\"\n    # Подключаемся к Viber\n    app = Application(backend=\"uia\").connect(title_re=\".*Viber.*\")\n    window = app.window(title_re=\".*Viber.*\")\n    window.set_focus()",
        "detail": "vb_utils",
        "documentation": {}
    },
    {
        "label": "right_click",
        "kind": 2,
        "importPath": "vb_utils",
        "description": "vb_utils",
        "peekOfCode": "def right_click(app, window_title, x=0, y=0):\n    \"\"\"\n    Устанавливает фокус на окно, а затем кликает правой кнопкой мыши по указанным координатам.\n    Args:\n        app: экземпляр pywinauto.Application\n        window_title: название окна\n        x: координата X для клика\n        y: координата Y для клика\n    \"\"\"\n    try:",
        "detail": "vb_utils",
        "documentation": {}
    },
    {
        "label": "right_click",
        "kind": 2,
        "importPath": "vb_utils",
        "description": "vb_utils",
        "peekOfCode": "def right_click(window, x=0, y=0):\n    \"\"\"\n    Кликает правой кнопкой мыши\n    \"\"\"\n    window.set_focus()\n    # Выполняем клик правой кнопкой мыши\n    mouse.click(button=\"right\", coords=(x, y))\n    log_and_print(f\"Right-clicked at ({x}, {y}) on the chat panel\")\ndef left_click(window, x=0, y=0):\n    \"\"\"",
        "detail": "vb_utils",
        "documentation": {}
    },
    {
        "label": "left_click",
        "kind": 2,
        "importPath": "vb_utils",
        "description": "vb_utils",
        "peekOfCode": "def left_click(window, x=0, y=0):\n    \"\"\"\n    Кликает левой кнопкой мыши\n    \"\"\"\n    # Выполняем клик левой кнопкой мыши\n    mouse.click(button=\"left\", coords=(x, y))\n    log_and_print(f\"Left-clicked at ({x}, {y}) on the chat panel\")\n# Глобальный флаг для предотвращения двойной реакции\nprocessed_messages = set()\n# Семафор для последовательной обработки сообщений",
        "detail": "vb_utils",
        "documentation": {}
    },
    {
        "label": "reformat_telegram_text",
        "kind": 2,
        "importPath": "vb_utils",
        "description": "vb_utils",
        "peekOfCode": "def reformat_telegram_text(input_text):\n    \"\"\"\n    Takes a text, finds all text enclosed in single asterisks (*),\n    and replaces them with double asterisks (**) for Telegram formatting.\n    Args:\n        input_text (str): The input text.\n    Returns:\n        str: The modified text with updated formatting.\n    \"\"\"\n    # Regular expression to find text enclosed in single asterisks",
        "detail": "vb_utils",
        "documentation": {}
    },
    {
        "label": "find_message_bottom_by_image",
        "kind": 2,
        "importPath": "vb_utils",
        "description": "vb_utils",
        "peekOfCode": "def find_message_bottom_by_image(\n    screenshot: ImageLike,\n    search_image: ImageLike,                        # <-- вместо search_words\n    search_roi: Optional[Tuple[int, int, int, int]] = None,  # (x,y,w,h) як і раніше\n    threshold: float = 0.83,                        # мін. кореляція для прийняття збігу\n    scales: Tuple[float, ...] = tuple(np.linspace(0.85, 1.15, 9)),  # мульти-скейл\n    return_debug: bool = False,\n) -> Dict[str, Union[int, float, Tuple[int,int,int,int], np.ndarray]]:\n    \"\"\"\n    Знаходить нижню межу повідомлення у Viber за шаблоном (search_image).",
        "detail": "vb_utils",
        "documentation": {}
    },
    {
        "label": "capture_and_find_image_boundary_coordinates",
        "kind": 2,
        "importPath": "vb_utils",
        "description": "vb_utils",
        "peekOfCode": "def capture_and_find_image_boundary_coordinates(\n    region,\n    search_image: ImageLike,\n    preprocess: bool = True,\n    visualize: bool = False,\n    threshold: float = 0.83\n) -> List[Tuple[int, int, int, int]]:\n    \"\"\"\n    Capture screenshot of `region`, find all matches of `search_image` (template),\n    and return rectangles [(x, y, w, h)] in screenshot-local coordinates.",
        "detail": "vb_utils",
        "documentation": {}
    },
    {
        "label": "ImageLike",
        "kind": 5,
        "importPath": "vb_utils",
        "description": "vb_utils",
        "peekOfCode": "ImageLike = Union[str, np.ndarray] \ndef scroll_with_mouse(window, count_scroll, direction=\"down\"):\n    window.set_focus()\n    # Находим панель с сообщениями\n    chat_pane = window.child_window(control_type=\"Pane\", found_index=0)\n    # Получаем координаты панели\n    rect = chat_pane.rectangle()\n    center_x = (rect.left + rect.right) // 2\n    center_y = (rect.top + rect.bottom) // 2\n    # Прокручиваем вниз",
        "detail": "vb_utils",
        "documentation": {}
    },
    {
        "label": "processed_messages",
        "kind": 5,
        "importPath": "vb_utils",
        "description": "vb_utils",
        "peekOfCode": "processed_messages = set()\n# Семафор для последовательной обработки сообщений\nprocessing_semaphore = asyncio.Semaphore(1)\nasync def process_one_message_telegramm(message_text, bot_client, channel_name, name_viber, file_path):\n    log_and_print(f\"bot_client: {bot_client}\", 'info')\n    log_and_print(f\"service_channel_name: {channel_name}\", 'info')\n    log_and_print(f\"name_viber: {name_viber}\", 'info')\n    if message_text:\n        # Добавляем ID сообщения в список обработанных\n        processed_messages.add(message_text)",
        "detail": "vb_utils",
        "documentation": {}
    },
    {
        "label": "processing_semaphore",
        "kind": 5,
        "importPath": "vb_utils",
        "description": "vb_utils",
        "peekOfCode": "processing_semaphore = asyncio.Semaphore(1)\nasync def process_one_message_telegramm(message_text, bot_client, channel_name, name_viber, file_path):\n    log_and_print(f\"bot_client: {bot_client}\", 'info')\n    log_and_print(f\"service_channel_name: {channel_name}\", 'info')\n    log_and_print(f\"name_viber: {name_viber}\", 'info')\n    if message_text:\n        # Добавляем ID сообщения в список обработанных\n        processed_messages.add(message_text)\n    elif file_path:\n        processed_messages.add(file_path)",
        "detail": "vb_utils",
        "documentation": {}
    }
]